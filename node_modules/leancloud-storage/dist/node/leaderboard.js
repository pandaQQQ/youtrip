'use strict';

var _ = require('underscore');
var Promise = require('./promise');

var _require = require('./request'),
    request = _require.request;

var _require2 = require('./utils'),
    ensureArray = _require2.ensureArray,
    parseDate = _require2.parseDate;

var AV = require('./av');

var LeaderboardVersionChangeInterval = {
  NEVER: 'never',
  HOUR: 'hour',
  DAY: 'day',
  WEEK: 'week',
  MONTH: 'month'
};

var LeaderboardOrder = {
  ASCENDING: 'ascending',
  DESCENDING: 'descending'
};

function Statistic(_ref) {
  var user = _ref.user,
      name = _ref.name,
      value = _ref.value,
      position = _ref.position,
      version = _ref.version;

  this.name = name;
  this.value = value;
  this.user = user;
  this.position = position;
  this.version = version;
}

function Leaderboard(statisticName) {
  this.statisticName = statisticName;
  this.versionChangeInterval = undefined;
  this.version = undefined;
  this.nextResetAt = undefined;
}

Leaderboard.createWithoutData = function (statisticName) {
  return new Leaderboard(statisticName);
};
Leaderboard.createLeaderboard = function (_ref2, authOptions) {
  var statisticName = _ref2.statisticName,
      order = _ref2.order,
      versionChangeInterval = _ref2.versionChangeInterval;
  return request({
    method: 'POST',
    path: '/play/leaderboards',
    data: {
      statisticName: statisticName,
      order: order,
      versionChangeInterval: versionChangeInterval
    },
    authOptions: authOptions
  }).then(function (data) {
    var leaderboard = new Leaderboard(statisticName);
    return leaderboard._finishFetch(data);
  });
};
Leaderboard.getLeaderboard = function (statisticName, authOptions) {
  return Leaderboard.createWithoutData(statisticName).fetch(authOptions);
};
Leaderboard.getStatistics = function (user, _ref3, authOptions) {
  var statisticNames = _ref3.statisticNames;
  return Promise.resolve().then(function () {
    if (!user || user.id) throw new Error('user must be an AV.User');
    return request({
      method: 'GET',
      path: 'play/users/' + user.id + '/statistics',
      data: {
        statistics: statisticNames ? ensureArray(statisticNames) : undefined
      },
      authOptions: authOptions
    }).then(function (data) {
      return data.map(function (statisticData) {
        var _AV$_decode = AV._decode(statisticData),
            name = _AV$_decode.statisticName,
            value = _AV$_decode.statisticValue,
            version = _AV$_decode.version;

        return new Statistic({ user: user, name: name, value: value, version: version });
      });
    });
  });
};
Leaderboard.updateStatistics = function (user, statistics, authOptions) {
  return Promise.resolve().then(function () {
    if (!user || user.id) throw new Error('user must be an AV.User');
    var data = _.mapObject(statistics, function (value, key) {
      return {
        statisticName: key,
        statisticValue: value
      };
    });
    return request({
      method: 'POST',
      path: 'play/users/' + user.id + '/statistics',
      data: data,
      authOptions: authOptions
    });
  });
};

_.extend(Leaderboard.prototype, {
  _finishFetch: function _finishFetch(data) {
    var _this = this;

    _.forEach(data, function (value, key) {
      if (key === 'updatedAt' || key === 'objectId') return;
      if (key === 'expiredAt') {
        key = 'nextResetAt';
      }
      if (value.__type === 'Date') {
        value = parseDate(value.iso);
      }
      _this[key] = value;
    });
    return this;
  },
  fetch: function fetch(authOptions) {
    var _this2 = this;

    return request({
      method: 'GET',
      path: '/play/leaderboards/' + this.statisticName,
      authOptions: authOptions
    }).then(function (data) {
      return _this2._finishFetch(data);
    });
  },
  _getResults: function _getResults(_ref4, authOptions, self) {
    var skip = _ref4.skip,
        limit = _ref4.limit,
        includeUserData = _ref4.includeUserData;

    return request({
      method: 'GET',
      path: '/play/leaderboards/' + this.statisticName + '/positions' + (self ? '/self' : ''),
      data: {
        skip: skip,
        limit: limit,
        includeUserData: includeUserData ? ensureArray(includeUserData) : undefined
      },
      authOptions: authOptions
    }).then(function (data) {
      return data.map(function (statisticData) {
        var _AV$_decode2 = AV._decode(statisticData),
            user = _AV$_decode2.user,
            name = _AV$_decode2.statisticName,
            value = _AV$_decode2.value,
            position = _AV$_decode2.position;

        return new Statistic({ user: user, name: name, value: value, position: position });
      });
    });
  },
  getResults: function getResults(_ref5, authOptions) {
    var skip = _ref5.skip,
        limit = _ref5.limit,
        includeUserData = _ref5.includeUserData;

    return this._getResults({ skip: skip, limit: limit, includeUserData: includeUserData }, authOptions);
  },
  getResultsAroundUser: function getResultsAroundUser(_ref6, authOptions) {
    var skip = _ref6.skip,
        limit = _ref6.limit,
        includeUserData = _ref6.includeUserData;

    return this._getResults({ skip: skip, limit: limit, includeUserData: includeUserData }, authOptions, true);
  },
  updateVersionChangeInterval: function updateVersionChangeInterval(versionChangeInterval, authOptions) {
    var _this3 = this;

    return request({
      method: 'PUT',
      path: '/play/leaderboards/' + this.statisticName,
      data: {
        versionChangeInterval: versionChangeInterval
      },
      authOptions: authOptions
    }).then(function (data) {
      return _this3._finishFetch(data);
    });
  },
  reset: function reset(authOptions) {
    var _this4 = this;

    return request({
      method: 'PUT',
      path: '/play/leaderboards/' + this.statisticName + '/incrementVersion',
      authOptions: authOptions
    }).then(function (data) {
      return _this4._finishFetch(data);
    });
  }
});

module.exports = {
  Leaderboard: Leaderboard,
  LeaderboardOrder: LeaderboardOrder,
  LeaderboardVersionChangeInterval: LeaderboardVersionChangeInterval
};